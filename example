import re
import unittest

def filter_metric_keys(metric_id_keys, scan_iter_preview):
    filtered_keys = [key for key in scan_iter_preview if any(re.match(fr"\d+::\d+::.*:{re.escape(metric_key)}:.*", key) for metric_key in metric_id_keys)]
    return filtered_keys

class TestFilterMetricKeys(unittest.TestCase):
    def test_filter_metric_keys(self):
        metric_id_keys = ['key1', 'key2', 'key3']
        scan_iter_preview = ['1::2::something:key1:something', '3::4::something:key2:something', '5::6::something:other_key:something']

        result = filter_metric_keys(metric_id_keys, scan_iter_preview)

        # Assert that the result is as expected
        self.assertEqual(result, ['1::2::something:key1:something', '3::4::something:key2:something'])

    def test_filter_metric_keys_empty_input(self):
        # Test with empty input lists
        metric_id_keys = []
        scan_iter_preview = []

        result = filter_metric_keys(metric_id_keys, scan_iter_preview)

        # Assert that the result is an empty list
        self.assertEqual(result, [])

    def test_filter_metric_keys_no_matches(self):
        # Test with no matches in the scan_iter_preview
        metric_id_keys = ['key1', 'key2', 'key3']
        scan_iter_preview = ['1::2::something:other_key:something', '3::4::something:another_key:something']

        result = filter_metric_keys(metric_id_keys, scan_iter_preview)

        # Assert that the result is an empty list
        self.assertEqual(result, [])

if __name__ == '__main__':
    unittest.main()
